/// <reference types="node" />
import { EventEmitter } from "events";
import { AnyError, Collection, Db as MongoDb, MongoClient, MongoClientOptions } from "mongodb";
import { Job } from "agenda/lib/job";
import { cancel } from "agenda/lib/agenda/cancel";
import { close } from "agenda/lib/agenda/close";
import { create } from "agenda/lib/agenda/create";
import { database } from "agenda/lib/agenda/database";
import { dbInit } from "agenda/lib/agenda/db-init";
import { defaultConcurrency } from "agenda/lib/agenda/default-concurrency";
import { defaultLockLifetime } from "agenda/lib/agenda/default-lock-lifetime";
import { defaultLockLimit } from "agenda/lib/agenda/default-lock-limit";
import { define } from "agenda/lib/agenda/define";
import { disable } from "agenda/lib/agenda/disable";
import { enable } from "agenda/lib/agenda/enable";
import { every } from "agenda/lib/agenda/every";
import { JobProcessingQueue } from "agenda/lib/agenda/job-processing-queue";
import { jobs } from "agenda/lib/agenda/jobs";
import { lockLimit } from "agenda/lib/agenda/lock-limit";
import { maxConcurrency } from "agenda/lib/agenda/max-concurrency";
import { mongo } from "agenda/lib/agenda/mongo";
import { name } from "agenda/lib/agenda/name";
import { now } from "agenda/lib/agenda/now";
import { processEvery } from "agenda/lib/agenda/process-every";
import { purge } from "agenda/lib/agenda/purge";
import { saveJob } from "agenda/lib/agenda/save-job";
import { schedule } from "agenda/lib/agenda/schedule";
import { sort } from "agenda/lib/agenda/sort";
import { start } from "agenda/lib/agenda/start";
import { stop } from "agenda/lib/agenda/stop";
import { drain } from 'agenda/lib/agenda/drain';
export interface AgendaConfig {
    name?: string;
    processEvery?: string;
    maxConcurrency?: number;
    defaultConcurrency?: number;
    lockLimit?: number;
    defaultLockLimit?: number;
    defaultLockLifetime?: number;
    sort?: any;
    mongo?: MongoDb;
    db?: {
        address: string;
        collection?: string;
        options?: MongoClientOptions;
    };
    disableAutoIndex?: boolean;
}
/**
 * @class Agenda
 * @param {Object} config - Agenda Config
 * @param {Function} cb - Callback after Agenda has started and connected to mongo
 * @property {Object} _name - Name of the current Agenda queue
 * @property {Number} _processEvery
 * @property {Number} _defaultConcurrency
 * @property {Number} _maxConcurrency
 * @property {Number} _defaultLockLimit
 * @property {Number} _lockLimit
 * @property {Object} _definitions
 * @property {Object} _runningJobs
 * @property {Object} _lockedJobs
 * @property {Object} _jobQueue
 * @property {Number} _defaultLockLifetime
 * @property {Object} _sort
 * @property {Object} _indices
 * @property {Boolean} _isLockingOnTheFly - true if 'lockingOnTheFly' is currently running. Prevent concurrent execution of this method.
 * @property {Map} _isJobQueueFilling - A map of jobQueues and if the 'jobQueueFilling' method is currently running for a given map. 'lockingOnTheFly' and 'jobQueueFilling' should not run concurrently for the same jobQueue. It can cause that lock limits aren't honored.
 * @property {Array} _jobsToLock
 */
declare class Agenda extends EventEmitter {
    _defaultConcurrency: any;
    _defaultLockLifetime: any;
    _defaultLockLimit: any;
    _definitions: any;
    _findAndLockNextJob: (this: Agenda, jobName: string, definition: any) => Promise<Job<import("agenda/lib/job").JobAttributesData> | undefined>;
    _indices: any;
    _disableAutoIndex: boolean;
    _isLockingOnTheFly: boolean;
    _isJobQueueFilling: Map<string, boolean>;
    _jobQueue: JobProcessingQueue;
    _jobsToLock: Job[];
    _lockedJobs: Job[];
    _runningJobs: Job[];
    _lockLimit: any;
    _maxConcurrency: any;
    _mongoUseUnifiedTopology?: boolean;
    _name: any;
    _processEvery: number;
    _ready: Promise<unknown>;
    _sort: any;
    _db: MongoClient;
    _mdb: MongoDb;
    _collection: Collection;
    _nextScanAt: any;
    _processInterval: any;
    cancel: typeof cancel;
    close: typeof close;
    create: typeof create;
    database: typeof database;
    db_init: typeof dbInit;
    defaultConcurrency: typeof defaultConcurrency;
    defaultLockLifetime: typeof defaultLockLifetime;
    defaultLockLimit: typeof defaultLockLimit;
    define: typeof define;
    disable: typeof disable;
    enable: typeof enable;
    every: typeof every;
    jobs: typeof jobs;
    lockLimit: typeof lockLimit;
    maxConcurrency: typeof maxConcurrency;
    mongo: typeof mongo;
    name: typeof name;
    now: typeof now;
    processEvery: typeof processEvery;
    purge: typeof purge;
    saveJob: typeof saveJob;
    schedule: typeof schedule;
    sort: typeof sort;
    start: typeof start;
    stop: typeof stop;
    drain: typeof drain;
    /**
     * Constructs a new Agenda object.
     * @param config Optional configuration to initialize the Agenda.
     * @param cb Optional callback called with the MongoDB collection.
     */
    constructor(config?: AgendaConfig, cb?: (error: AnyError | undefined, collection: Collection<any> | null) => void);
}
export { Agenda };
//# sourceMappingURL=index.d.ts.map